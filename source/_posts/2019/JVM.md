---
title: 并发1:JVM
permalink: JVM
date: 2019-08-12 23:43:22
tags:
categories: concurrent
---
# JVM

[转载自](https://segmentfault.com/a/1190000014395186?utm_source=tag-newest#articleHeader0)

## Java运行时数据区
> Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图：

<!--more-->

![image.png](https://cdn.nlark.com/yuque/0/2019/png/178066/1565622823732-7478c163-a1a3-4dfe-8df1-f49fdd86d4f3.png#align=left&display=inline&height=423&name=image.png&originHeight=423&originWidth=536&size=96974&status=done&width=536)

1. 程序计数器：指向当前线程正在执行的字节码指令。线程私有的。
1. 虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。
  1. 栈帧：栈帧存储方法的相关信息，包含局部变量数表、返回值、操作数栈、动态链接
    1. 局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。
    1. 返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。
    1. 操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。
    1. 动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。
  2. 线程私有
3. 本地方法栈：
  1. 调用本地native的内存模型
  1. 线程独享。
4. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
  1. 线程共享的
  1. 运行时常量池：
> A、是方法区的一部分
> B、存放编译期生成的各种字面量和符号引用
> C、Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池中。

5. 堆（Heap）：Java对象存储的地方
  1. Java堆是虚拟机管理的内存中最大的一块
  1. Java堆是所有线程共享的区域
  1. 在虚拟机启动时创建
  1. 此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组
  1. Java堆是垃圾收集器管理的内存区域，因此很多时候称为“GC堆”


---



## JMM Java内存模型：

1.  Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。
1. 主要目的是定义程序中各个变量的访问规则。
1. Java内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。
  1. 线程的工作内存中保存了被该线程使用到的变量的拷贝（从主内存中拷贝过来），线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。
  1. 不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递都要通过主内存来完成。
  1. 主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。

![image.png](https://cdn.nlark.com/yuque/0/2019/png/178066/1565622908799-c0f1ffa7-5841-422b-bd96-151feddfb6c8.png#align=left&display=inline&height=340&name=image.png&originHeight=340&originWidth=745&size=158422&status=done&width=745)

4. Java线程之间的通信由内存模型JMM（Java Memory Model）控制。
- JMM决定一个线程对变量的写入何时对另一个线程可见。
- 线程之间共享变量存储在主内存中
- 每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。
- JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。
5. 可见性、有序性：
- 当一个共享变量在多个本地内存中有副本时，如果一个本地内存修改了该变量的副本，其他变量应该能够看到修改后的值，此为可见性。
- 保证线程的有序执行，这个为有序性。（保证线程安全）
6. 内存间交互操作：
  1. lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
  1. unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
  1. read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。
  1. load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中
  1. use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。
  1. assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。
  1. store（存储）：把工作内存的变量的值传递给主内存
  1. write（写入）：把store操作的值入到主内存的变量中

**注意：**

- 不允许read、load、store、write操作之一单独出现
- 不允许一个线程丢弃assgin操作
- 不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中
- 一个新的变量只能在主内存中生成
- 一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁
- 如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。
- 如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量
- 对一个变量执行unlock操作之前，需要将该变量同步回主内存中


---



## 堆的内存划分：
![image.png](https://cdn.nlark.com/yuque/0/2019/png/178066/1565622945913-0f20f3fa-3c53-4d59-b196-79de1dccc3bb.png#align=left&display=inline&height=253&name=image.png&originHeight=253&originWidth=698&size=54225&status=done&width=698)
  Java堆的内存划分如图所示，分别为年轻代、Old Memory（老年代）、Perm（永久代）。其中在Jdk1.8中，永久代被移除，使用MetaSpace代替。

1. 新生代：
  1. 使用复制清除算法（Copinng算法），原因是年轻代每次GC都要回收大部分对象。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。
  1. 分为Eden、Survivor From、Survivor To，比例默认为8：1：1
  1. 内存不足时发生Minor GC
2. 老年代：
  1. 采用标记-整理算法（mark-compact），原因是老年代每次GC只会回收少部分对象。
3. Perm：用来存储类的元数据，也就是方法区。
  1. Perm的废除：在jdk1.8中，Perm被替换成MetaSpace，MetaSpace存放在本地内存中。原因是永久代进场内存不够用，或者发生内存泄漏。
  1. MetaSpace（元空间）：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
4. 堆内存的划分在JVM里面的示意图：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/178066/1565622972836-f2dce602-b1ea-4fec-83d2-1a800c4f7926.png#align=left&display=inline&height=477&name=image.png&originHeight=477&originWidth=818&size=140755&status=done&width=818)

---



## GC垃圾回收：

### 判断对象是否要回收的方法：可达性分析法

1. 通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的）
1. 以下对象会被认为是root对象：
  1. 虚拟机栈（栈帧中本地变量表）中引用的对象
  1. 方法区中静态属性引用的对象
  1. 方法区中常量引用的对象
  1. 本地方法栈中Native方法引用的对象
3. 对象被判定可被回收，需要经历两个阶段：
  1. 第一个阶段是可达性分析，分析该对象是否可达
  1. 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会）
4. 方法区中的垃圾回收：
4. 常量池中一些常量、符号引用没有被引用，则会被清理出常量池
4. 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：
  - 该类的所有实例被回收
  - 加载该类的ClassLoader被回收
  - 该类的Class对象没有被引用
7. finalize():
  - GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。
  -  可以在该方法里面，指定一些对象在释放前必须执行的操作。

### 发现虚拟机频繁full GC时应该怎么办：
（full GC指的是清理整个堆空间，包括年轻代和永久代）

  - 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id
  - 如果是System.gc()，则看下代码哪里调用了这个方法
  - 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令
  - 如果是GC locker，可能是程序依赖的JNI库的原因

### 常见的垃圾回收算法：

1. Mark-Sweep（标记-清除算法）：
  - 思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。
  - 优缺点：实现简单，容易产生内存碎片
2. Copying（复制清除算法）：
  - 思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。
  - 优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。
3. Mark-Compact（标记-整理算法）：
  - 思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。
  - 优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下
4. 分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：
> 思想：把堆分成新生代和老年代。（永久代指的是方法区）

  1. 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。
  1. 由于老年代每次只回收少量的对象，因此采用mark-compact算法。
  1. 在堆区外有一个永久代。对永久代的回收主要是无效的类和常量
5. GC使用时对程序的影响？ 

垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间

6. 几种不同的垃圾回收类型：
- Minor GC：从年轻代（包括Eden、Survivor区）回收内存。
> A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC
> B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。

- Major GC：清理整个老年代，当eden区内存不足时触发。
- Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发